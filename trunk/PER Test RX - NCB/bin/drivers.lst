ANSI-C/cC++ Compiler for HC08 V-5.0.24 Build 7134, May 15 2007

    1:  
    2:  /*!
    3:   * Copyright (c) 2005, Freescale Semiconductor
    4:   *
    5:   * Freescale Confidential Proprietary
    6:   * \file    drivers.c
    7:   * \brief   This is the SMAC C source driver file for the HC(S)08
    8:   * MCU and MC13192 transceiver.
    9:   * \author  r01160
   10:   * \version 4.1a
   11:   * \date    2005/07/29 03:30:40 
   12:   * 
   13:   * \b Description:
   14:   *
   15:   * The driver controls all interfaces to/from the MC13192 by the SPI,
   16:   * selected interrupt source and MCU GPIO's assigned to other MC13192
   17:   * pins.The SMAC driver is the lowest layer of C code.
   18:   * Actual hardware interconnects from the MCU to the MC13192 are 
   19:   * defined in the MC13192_hw_config.h header file.
   20:   *
   21:   * \b Department: Freescale Radio Products Division 
   22:   *
   23:   * \b Project: SMAC (Simple Media Access Controller)
   24:   *
   25:   * \b History:
   26:   * - 16/11/2005 Doc. update to Doxygen compliant by Mario Rodriguez r12369c
   27:   */ 
   28:   
   29:  #include "mcu_hw_config.h"
   30:  #include "pub_def.h"
   31:  #include "drivers.h"
   32:  #include "simple_phy.h"
   33:  #include "MC13192_hw_config.h"
   34:  #include "MC13192_regs.h"
   35:  
   36:  /* Globals */
   37:  tRxPacket *psDrvRxPacket;           //!< Where the packet received will be stored 
   38:  tCCAMeasurement sDrvCCAReading;     //!< NOT USED  
   39:  extern UINT8 gu8RTxMode;						//!< Global mode mirror. MC13192 Status. 
   40:  UINT8 gu8IRQValue = 0;							//!< IRQ value  
   41:  extern tPhyOptions gsPhyOptions;
   42:  volatile UINT16 u16StatusContent;
   43:  
   44:  /*!
   45:   * \brief  MC13192 initiated IRQ interrupt handler.
   46:   * The vector is defined in vectortable.c
   47:   *
   48:   * \return The interrupt will RTI unless valid data is recvd.
   49:   * In this case a PDDataIndication function call-back will be 
   50:   * executed first, followed by a RTI.
   51:   *
   52:   */
   53:  interrupt void  IRQIsr(void)   
   54:  {
  0000 8b       [2]             PSHH  
  0001 a7f8     [2]             AIS   #-8
   55:    
   56:      /* Result of the status register read */
   57:      volatile UINT16 u16StatusContent, u16Reg, u16Temp;   
   58:      /* Data length for the RX packet */
   59:      UINT8 u8DataLength = 0;     
   60:      UINT8 u8MinLen = 0;
   61:      #if defined (HCS08G) | defined (HCS08R)
   62:      /* Acknowledge the interrupt. MC13192 IRQ pin still low.*/
   63:      CLEAR_IRQ_FLAG();   
  0003 1400     [5]             BSET  2,_IRQSC
   64:      #endif
   65:      u16StatusContent = SPIDrvRead(STATUS_ADDR); /* 
  0005 a624     [2]             LDA   #36
  0007 cd0000   [6]             JSR   SPIDrvRead
  000a 9eff02   [5]             STHX  2,SP
   66:                                                   * Read the MC13192 status 
   67:                                                   * register.
   68:                                                   */
   69:      /* Test for IRQ glitch or possible fast double IRQ. */
   70:  
   71:      if(IRQPinLow())       //__isflag_int_enabled
  000d cd0000   [6]             JSR   IRQPinLow
  0010 4d       [1]             TSTA  
  0011 2725     [3]             BEQ   L38 ;abs = 0038
   72:      {        
   73:     
   74:          CLEAR_IRQ_FLAG();   /* Acknowledge the interrupt. MC13192 IRQ pin still low. */     
  0013 1400     [5]             BSET  2,_IRQSC
   75:          u16Reg = SPIDrvRead(STATUS_ADDR);   /* Read the MC13192 status register. */
  0015 a624     [2]             LDA   #36
  0017 cd0000   [6]             JSR   SPIDrvRead
  001a 9eff07   [5]             STHX  7,SP
   76:          u16StatusContent = u16StatusContent | u16Reg;   /* 
  001d 9efe07   [5]             LDHX  7,SP
  0020 89       [2]             PSHX  
  0021 8b       [2]             PSHH  
  0022 9efe04   [5]             LDHX  4,SP
  0025 9f       [1]             TXA   
  0026 8b       [2]             PSHH  
  0027 95       [2]             TSX   
  0028 ea02     [3]             ORA   2,X
  002a e702     [3]             STA   2,X
  002c 86       [3]             PULA  
  002d ea01     [3]             ORA   1,X
  002f 87       [2]             PSHA  
  0030 ee02     [3]             LDX   2,X
  0032 8a       [3]             PULH  
  0033 9eff04   [5]             STHX  4,SP
  0036 a702     [2]             AIS   #2
  0038          L38:    
   77:                                                           * Actual status is the OR 
   78:                                                           * of both.
   79:                                                           */
   80:      }   
   81:      
   82:      if (gsPhyOptions.Bits.u1PromiscuousMode)
  0038 c60001   [4]             LDA   gsPhyOptions:1
  003b a501     [2]             BIT   #1
  003d 2704     [3]             BEQ   L43 ;abs = 0043
   83:        u8MinLen = 3;
  003f a603     [2]             LDA   #3
  0041 2002     [3]             BRA   L45 ;abs = 0045
  0043          L43:    
   84:      else
   85:        u8MinLen = 5;
  0043 a605     [2]             LDA   #5
  0045          L45:    
   86:  
   87:      u16StatusContent &= TX_IRQ_MASK | RX_IRQ_MASK | ATTN_IRQ_MASK | \
  0045 9efe02   [5]             LDHX  2,SP
  0048 87       [2]             PSHA  
  0049 9f       [1]             TXA   
  004a a4e3     [2]             AND   #-29
  004c 87       [2]             PSHA  
  004d 8b       [2]             PSHH  
  004e 86       [3]             PULA  
  004f a487     [2]             AND   #-121
  0051 87       [2]             PSHA  
  0052 8a       [3]             PULH  
  0053 88       [3]             PULX  
  0054 9eff03   [5]             STHX  3,SP
   88:                          CRC_VALID_MASK | TIMER1_IRQ_MASK | CCA_IRQ_MASK | \
   89:                          LO_LOCK_IRQ_MASK | DOZE_IRQ_MASK | CCA_BIT_MASK;
   90:                          
   91:      if (gu8RTxMode != RX_MODE_WTO) {
  0057 c60000   [4]             LDA   gu8RTxMode
  005a a180     [2]             CMP   #-128
  005c cd0000   [6]             JSR   _PUSH_CC
  005f 9ee605   [4]             LDA   5,SP
  0062 cd0000   [6]             JSR   _POP_CC
  0065 8a       [3]             PULH  
  0066 270f     [3]             BEQ   L77 ;abs = 0077
   92:          /* If timeout not being used, mask out timer. */
   93:          u16StatusContent &= ~(TIMER1_IRQ_MASK);
  0068 9eee03   [4]             LDX   3,SP
  006b 9eef03   [4]             STX   3,SP
  006e 87       [2]             PSHA  
  006f 95       [2]             TSX   
  0070 e602     [3]             LDA   2,X
  0072 a4fe     [2]             AND   #-2
  0074 e702     [3]             STA   2,X
  0076 86       [3]             PULA  
  0077          L77:    
   94:      }
   95:      
   96:      if ((u16StatusContent & ~(CRC_VALID_MASK)) == 0) {
  0077 95       [2]             TSX   
  0078 f7       [2]             STA   ,X
  0079 e602     [3]             LDA   2,X
  007b a4fe     [2]             AND   #-2
  007d 87       [2]             PSHA  
  007e e601     [3]             LDA   1,X
  0080 87       [2]             PSHA  
  0081 8a       [3]             PULH  
  0082 88       [3]             PULX  
  0083 650000   [3]             CPHX  #0
  0086 2603     [3]             BNE   L8B ;abs = 008b
  0088 cc0223   [4]             JMP   L223 ;abs = 0223
  008b          L8B:    
   97:          /* If no status bits are set just return. */
   98:          return;
   99:      }
  100:      
  101:      /* DOZE Complete Interrupt */
  102:      if ((u16StatusContent & DOZE_IRQ_MASK) != 0) {
  008b 5f       [1]             CLRX  
  008c a402     [2]             AND   #2
  008e 87       [2]             PSHA  
  008f 8a       [3]             PULH  
  0090 650000   [3]             CPHX  #0
  0093 cd0000   [6]             JSR   _PUSH_CC
  0096 9ee605   [4]             LDA   5,SP
  0099 cd0000   [6]             JSR   _POP_CC
  009c 272a     [3]             BEQ   LC8 ;abs = 00c8
  103:          SPIDrvWrite(T2_HI_ADDR, 0x8000); /* disable the timer2 */
  009e 95       [2]             TSX   
  009f f7       [2]             STA   ,X
  00a0 a61d     [2]             LDA   #29
  00a2 458000   [3]             LDHX  #-32768
  00a5 cd0000   [6]             JSR   SPIDrvWrite
  104:          u16Temp= SPIDrvRead(MODE2_ADDR);
  00a8 a607     [2]             LDA   #7
  00aa cd0000   [6]             JSR   SPIDrvRead
  00ad 9eff04   [5]             STHX  4,SP
  105:          u16Temp &= 0xFFFC;
  00b0 9efe04   [5]             LDHX  4,SP
  00b3 9f       [1]             TXA   
  00b4 a4fc     [2]             AND   #-4
  00b6 97       [1]             TAX   
  00b7 9eff04   [5]             STHX  4,SP
  106:          SPIDrvWrite(MODE2_ADDR, u16Temp);/* disable doze/hibernate modes */      
  00ba a607     [2]             LDA   #7
  00bc 9efe04   [5]             LDHX  4,SP
  00bf cd0000   [6]             JSR   SPIDrvWrite
  107:          gu8RTxMode = IDLE_MODE;        
  00c2 4f       [1]             CLRA  
  00c3 c70000   [4]             STA   gu8RTxMode
  00c6 95       [2]             TSX   
  00c7 f6       [3]             LDA   ,X
  00c8          LC8:    
  108:      }  
  109:      
  110:      /* ATTN IRQ Handler*/
  111:      if ((u16StatusContent & ATTN_IRQ_MASK) != 0) {
  00c8 5f       [1]             CLRX  
  00c9 9ee701   [4]             STA   1,SP
  00cc 9ee602   [4]             LDA   2,SP
  00cf a404     [2]             AND   #4
  00d1 87       [2]             PSHA  
  00d2 8a       [3]             PULH  
  00d3 650000   [3]             CPHX  #0
  00d6 2728     [3]             BEQ   L100 ;abs = 0100
  112:         /* 
  113:          * If attn interrupt, set the rtx_state mirror.
  114:          * For MC13192 V2.x devices, read the reset indication in R25/7 first. 
  115:          * If a reset is indicated, call back to a reset handler. 
  116:          */
  117:          u16StatusContent = SPIDrvRead(RESIND_ADDR); /* 
  00d8 a625     [2]             LDA   #37
  00da cd0000   [6]             JSR   SPIDrvRead
  00dd 9eff02   [5]             STHX  2,SP
  118:                                                       * Read the MC13192 reset 
  119:                                                       * indicator register.
  120:                                                       */
  121:          u16StatusContent &= RESET_BIT_MASK;
  00e0 9eee03   [4]             LDX   3,SP
  00e3 9f       [1]             TXA   
  00e4 a480     [2]             AND   #-128
  00e6 8c       [1]             CLRH  
  00e7 97       [1]             TAX   
  00e8 9eff02   [5]             STHX  2,SP
  122:          if (u16StatusContent == 0) {            /* Reset */
  00eb 9efe02   [5]             LDHX  2,SP
  00ee 260b     [3]             BNE   LFB ;abs = 00fb
  123:              gu8RTxMode = MC13192_RESET_MODE;    /* 
  00f0 a687     [2]             LDA   #-121
  00f2 c70000   [4]             STA   gu8RTxMode
  124:                                                   * Set the rtx_state mirror to 
  125:                                                   * idle with attn.
  126:                                                   */
  127:              PLMEMC13192ResetIndication();
  00f5 cd0000   [6]             JSR   PLMEMC13192ResetIndication
  128:              return;
  00f8 cc0223   [4]             JMP   L223 ;abs = 0223
  00fb          LFB:    
  129:          }
  130:          else {
  131:              gu8RTxMode = IDLE_MODE_ATTN;    /* 
  00fb a684     [2]             LDA   #-124
  132:                                               * Set the rtx_state mirror to idle
  133:                                               * with attn.
  134:                                               */
  135:              return;
  00fd cc018a   [4]             JMP   L18A ;abs = 018a
  0100          L100:   
  136:          }
  137:      }
  138:      /* TIMER1 IRQ Handler (Used for receiver timeout notification) */
  139:      if ((u16StatusContent & TIMER1_IRQ_MASK) != 0) {
  0100 9ee602   [4]             LDA   2,SP
  0103 a401     [2]             AND   #1
  0105 87       [2]             PSHA  
  0106 8a       [3]             PULH  
  0107 650000   [3]             CPHX  #0
  010a cd0000   [6]             JSR   _PUSH_CC
  010d 9ee605   [4]             LDA   5,SP
  0110 cd0000   [6]             JSR   _POP_CC
  0113 2727     [3]             BEQ   L13C ;abs = 013c
  140:          /* If timeout ocurs (and timeout enabled), update mode mirror state. */  
  141:          if (gu8RTxMode == RX_MODE_WTO) {
  0115 ce0000   [4]             LDX   gu8RTxMode
  0118 a380     [2]             CPX   #-128
  011a 2620     [3]             BNE   L13C ;abs = 013c
  142:              /* Clear Timer1 if in RX_MODE_WTO */
  143:              SPIDrvWrite(T1_HI_ADDR, 0x8000); /* Disables TC1 and clears IRQ */
  011c a61b     [2]             LDA   #27
  011e 458000   [3]             LDHX  #-32768
  0121 cd0000   [6]             JSR   SPIDrvWrite
  144:              SPIDrvWrite(T1_LO_ADDR, 0x0000);
  0124 a61c     [2]             LDA   #28
  0126 5f       [1]             CLRX  
  0127 8c       [1]             CLRH  
  0128 cd0000   [6]             JSR   SPIDrvWrite
  145:              psDrvRxPacket->u8Status = TIMEOUT;
  012b a685     [2]             LDA   #-123
  012d 320000   [5]             LDHX  psDrvRxPacket
  0130 e704     [3]             STA   4,X
  146:              RTXENDeAssert();                 /* Forces the MC13192 to idle. */
  0132 cd0000   [6]             JSR   RTXENDeAssert
  147:              gu8RTxMode = IDLE_MODE;
  0135 4f       [1]             CLRA  
  0136 c70000   [4]             STA   gu8RTxMode
  148:              PDDataIndication();              /* TIMEOUT notification */
  149:              return;
  0139 cc0220   [4]             JMP   L220 ;abs = 0220
  013c          L13C:   
  150:          }
  151:      }
  152:      /* LO LOCK IRQ - Occurs when MC13192 loses LOCK */
  153:      /* For receive cycles, re-enable. For transmit/CCA, abort. */
  154:      if ((u16StatusContent & LO_LOCK_IRQ_MASK) != 0) {
  013c 5f       [1]             CLRX  
  013d 9ee701   [4]             STA   1,SP
  0140 9ee602   [4]             LDA   2,SP
  0143 a480     [2]             AND   #-128
  0145 87       [2]             PSHA  
  0146 8a       [3]             PULH  
  0147 650000   [3]             CPHX  #0
  014a 2721     [3]             BEQ   L16D ;abs = 016d
  155:          RTXENDeAssert(); /* Forces the MC13192 to idle. */
  014c cd0000   [6]             JSR   RTXENDeAssert
  156:          /* Unlock from receive cycles */
  157:          if ((gu8RTxMode == RX_MODE) || (gu8RTxMode == RX_MODE_WTO) || \
  014f c60000   [4]             LDA   gu8RTxMode
  0152 a102     [2]             CMP   #2
  0154 2603     [3]             BNE   L159 ;abs = 0159
  0156 cc01e8   [4]             JMP   L1E8 ;abs = 01e8
  0159          L159:   
  0159 a180     [2]             CMP   #-128
  015b 2603     [3]             BNE   L160 ;abs = 0160
  015d cc01e8   [4]             JMP   L1E8 ;abs = 01e8
  0160          L160:   
  0160 a101     [2]             CMP   #1
  0162 2603     [3]             BNE   L167 ;abs = 0167
  0164 cc01e8   [4]             JMP   L1E8 ;abs = 01e8
  0167          L167:   
  0167 a143     [2]             CMP   #67
  0169 261e     [3]             BNE   L189 ;abs = 0189
  158:              (gu8RTxMode == CCA_MODE) || (gu8RTxMode == PULSE_TX_MODE)) {
  159:              /* Read the MC13192 trx register. Timer trigger off. */
  160:              u16StatusContent = (SPIDrvRead(MODE_ADDR) & 0xFF7F); 
  161:              SPIDrvWrite(MODE_ADDR, u16StatusContent);   /* 
  162:                                                           * Re-write the trx 
  163:                                                           * register.
  164:                                                           */  
  165:              RTXENAssert();          /* Re-start the sequence. */
  166:          }
  016b 207b     [3]             BRA   L1E8 ;abs = 01e8
  016d          L16D:   
  167:          else {
  168:              gu8RTxMode = IDLE_MODE;
  169:          }
  170:          return;
  171:      }
  172:      if ((gu8RTxMode == IDLE_MODE) || ((u16StatusContent & CCA_IRQ_MASK) != 0) || \
  016d c60000   [4]             LDA   gu8RTxMode
  0170 270e     [3]             BEQ   L180 ;abs = 0180
  0172 9ee603   [4]             LDA   3,SP
  0175 a420     [2]             AND   #32
  0177 2607     [3]             BNE   L180 ;abs = 0180
  0179 9ee603   [4]             LDA   3,SP
  017c a440     [2]             AND   #64
  017e 2710     [3]             BEQ   L190 ;abs = 0190
  0180          L180:   
  173:         ((u16StatusContent & TX_IRQ_MASK) != 0)) {
  174:          /* If in idle mode already or if CCA or TX is done, just return. */
  175:          RTXENDeAssert();            /* Forces the MC13192 to idle. */
  0180 cd0000   [6]             JSR   RTXENDeAssert
  176:          
  177:          
  178:          /* Check for Pulse TX Mode for PRBS9 Test mode sequence */
  179:          if (gu8RTxMode == PULSE_TX_MODE) {
  0183 c60000   [4]             LDA   gu8RTxMode
  0186 41435f   [4]             CBEQA #67,L1E8 ;abs = 01e8
  0189          L189:   
  180:                  u16StatusContent = (SPIDrvRead(MODE_ADDR) & 0xFF7F); /* Read the MC13192 trx register. Timer trigger off. */
  181:                  SPIDrvWrite(MODE_ADDR, u16StatusContent); /* Re-write the trx register. */  
  182:                    RTXENAssert(); /* Re-start the sequence. */
  183:              
  184:                  #if defined (PA)
  185:              MC13192_PA_CTRL = PA_OFF;       //Turn off the PA when TX is complete
  186:              #endif
  187:              return;
  188:          }
  189:          
  190:          gu8RTxMode = IDLE_MODE;
  0189 4f       [1]             CLRA  
  018a          L18A:   
  018a c70000   [4]             STA   gu8RTxMode
  018d cc0223   [4]             JMP   L223 ;abs = 0223
  0190          L190:   
  191:          return;
  192:      }
  193:      /* If rx is done */
  194:      if ((u16StatusContent & RX_IRQ_MASK) != 0) 
  0190 9ee603   [4]             LDA   3,SP
  0193 a480     [2]             AND   #-128
  0195 2603     [3]             BNE   L19A ;abs = 019a
  0197 cc0223   [4]             JMP   L223 ;abs = 0223
  019a          L19A:   
  195:      {  
  196:          RTXENDeAssert();            /* Forces the MC13192 to idle. */
  019a cd0000   [6]             JSR   RTXENDeAssert
  197:          if (((u16StatusContent & CRC_VALID_MASK) == 0) && ((gsPhyOptions.Bits.u1PromiscuousMode == FALSE))) 
  019d 95       [2]             TSX   
  019e e602     [3]             LDA   2,X
  01a0 a401     [2]             AND   #1
  01a2 cd0000   [6]             JSR   _PUSH_CC
  01a5 f6       [3]             LDA   ,X
  01a6 cd0000   [6]             JSR   _POP_CC
  01a9 2612     [3]             BNE   L1BD ;abs = 01bd
  01ab 87       [2]             PSHA  
  01ac c60001   [4]             LDA   gsPhyOptions:1
  01af a501     [2]             BIT   #1
  01b1 cd0000   [6]             JSR   _PUSH_CC
  01b4 9ee605   [4]             LDA   5,SP
  01b7 cd0000   [6]             JSR   _POP_CC
  01ba 8a       [3]             PULH  
  01bb 272b     [3]             BEQ   L1E8 ;abs = 01e8
  01bd          L1BD:   
  198:          {
  199:              /* If an invalid CRC, restart receiver. */
  200:              /* Read the MC13192 trx register. Timer trigger off. */
  201:              u16StatusContent = (SPIDrvRead(MODE_ADDR) & 0xFF7F); 
  202:              /* Update the trx register */          
  203:              SPIDrvWrite(MODE_ADDR, u16StatusContent); 
  204:              RTXENAssert(); /* Forces the MC13192 to enter the receive mode. */
  205:              return;
  206:          }
  207:          else {
  208:              /* Read received packet length register and mask off length bits */
  209:              u8DataLength = (UINT8) (SPIDrvRead(RX_PKT_LEN) & 0x7F);
  01bd 87       [2]             PSHA  
  01be a62d     [2]             LDA   #45
  01c0 cd0000   [6]             JSR   SPIDrvRead
  01c3 9f       [1]             TXA   
  01c4 a47f     [2]             AND   #127
  01c6 95       [2]             TSX   
  01c7 e706     [3]             STA   6,X
  210:              if (u8DataLength < u8MinLen) /* Rx_pkt_length is bad when <5 because of CRC and byte codes. */
  01c9 f1       [3]             CMP   ,X
  01ca 8a       [3]             PULH  
  01cb 251b     [3]             BCS   L1E8 ;abs = 01e8
  211:              {
  212:                  /* Read the MC13192 trx register. Timer trigger off. */                
  213:                  u16StatusContent = (SPIDrvRead(MODE_ADDR) & 0xFF7F); 
  214:                  /* Update the trx register. */ 
  215:                  SPIDrvWrite(MODE_ADDR, u16StatusContent);
  216:                  /* Forces the MC13192 to enter the receive mode. */
  217:                  RTXENAssert();  
  218:                  return;
  219:              }
  220:              /* Test the Byte Codes */
  221:              if (gsPhyOptions.Bits.u1PromiscuousMode == 0)
  01cd c60001   [4]             LDA   gsPhyOptions:1
  01d0 a501     [2]             BIT   #1
  01d2 262d     [3]             BNE   L201 ;abs = 0201
  222:              {
  223:                u16Temp = SPIDrvRead2(RX_PKT); /* Get the code bytes */
  01d4 a601     [2]             LDA   #1
  01d6 cd0000   [6]             JSR   SPIDrvRead2
  01d9 9eff04   [5]             STHX  4,SP
  224:                
  225:                if ((u16Temp != 0xFF7E) && ((gsPhyOptions.Bits.u1PromiscuousMode == FALSE)))
  01dc 65ff7e   [3]             CPHX  #-130
  01df 2720     [3]             BEQ   L201 ;abs = 0201
  01e1 c60001   [4]             LDA   gsPhyOptions:1
  01e4 a501     [2]             BIT   #1
  01e6 2619     [3]             BNE   L201 ;abs = 0201
  01e8          L1E8:   
  226:                {
  227:                    /* Read the MC13192 trx register. Timer trigger off. */                
  228:                    u16StatusContent = (SPIDrvRead(MODE_ADDR) & 0xFF7F); 
  01e8 a606     [2]             LDA   #6
  01ea cd0000   [6]             JSR   SPIDrvRead
  01ed 9f       [1]             TXA   
  01ee a47f     [2]             AND   #127
  01f0 97       [1]             TAX   
  01f1 9eff02   [5]             STHX  2,SP
  229:                    /* Update the trx register. */ 
  230:                    SPIDrvWrite(MODE_ADDR, u16StatusContent);
  01f4 a606     [2]             LDA   #6
  01f6 9efe02   [5]             LDHX  2,SP
  01f9 cd0000   [6]             JSR   SPIDrvWrite
  231:                    /* Forces the MC13192 to enter the receive mode. */
  232:                    RTXENAssert();  
  01fc cd0000   [6]             JSR   RTXENAssert
  01ff 2022     [3]             BRA   L223 ;abs = 0223
  0201          L201:   
  233:                    return;
  234:                }
  235:                
  236:              }
  237:              
  238:              /* A valid packet has been received. */
  239:              gu8RTxMode = IDLE_MODE;             /* Set the rtx_state to idle */
  0201 5f       [1]             CLRX  
  0202 cf0000   [4]             STX   gu8RTxMode
  240:              SPIDrvWrite(T1_HI_ADDR, 0x8000);    /* 
  0205 a61b     [2]             LDA   #27
  0207 458000   [3]             LDHX  #-32768
  020a cd0000   [6]             JSR   SPIDrvWrite
  241:                                                   * Disables TC1 and clears the 
  242:                                                   * IRQ. 
  243:                                                   */
  244:              SPIDrvWrite(T1_LO_ADDR, 0x0000);
  020d a61c     [2]             LDA   #28
  020f 5f       [1]             CLRX  
  0210 8c       [1]             CLRH  
  0211 cd0000   [6]             JSR   SPIDrvWrite
  245:              psDrvRxPacket->u8DataLength = u8DataLength;
  0214 9ee606   [4]             LDA   6,SP
  0217 320000   [5]             LDHX  psDrvRxPacket
  021a e701     [3]             STA   1,X
  246:              psDrvRxPacket->u8Status = SUCCESS;
  021c a677     [2]             LDA   #119
  021e e704     [3]             STA   4,X
  0220          L220:   
  247:              PDDataIndication(); /* Notify PHY that there is data available. */
  0220 cd0000   [6]             JSR   PDDataIndication
  0223          L223:   
  248:              return;
  249:          }
  250:      }
  251:  }
  0223 a708     [2]             AIS   #8
  0225 8a       [3]             PULH  
  0226 80       [9]             RTI   
  252:  
  253:  
  254:  /*!
  255:   * \brief SPIDrvWrite : Write 1 word to SPI
  256:   *
  257:   * \param u8Addr - SPI address
  258:   * \param u16Content - Data to send
  259:   *
  260:   */
  261:  void SPIDrvWrite(UINT8 u8Addr, UINT16 u16Content)
  262:  {
  0000 87       [2]             PSHA  
  0001 89       [2]             PSHX  
  0002 8b       [2]             PSHH  
  0003 8b       [2]             PSHH  
  263:    UINT8 u8TempValue=0;
  0004 95       [2]             TSX   
  0005 7f       [4]             CLR   ,X
  264:  
  265:    SPIClearRecieveStatReg(&u8TempValue); /* Clear status register (possible SPRF, SPTEF) */  
  0006 cd0000   [6]             JSR   SPIClearRecieveStatReg
  266:    SPIClearRecieveDataReg(&u8TempValue); /* 
  0009 95       [2]             TSX   
  000a cd0000   [6]             JSR   SPIClearRecieveDataReg
  267:                               * Clear receive data register. SPI entirely ready 
  268:                               * for read or write 
  269:                               */                       
  270:    MC13192DisableInterrupts();   /* Necessary to prevent double SPI access */
  000d cd0000   [6]             JSR   MC13192DisableInterrupts
  271:    AssertCE();                   /* Enables MC13192 SPI */
  0010 cd0000   [6]             JSR   AssertCE
  272:    SPISendChar(u8Addr & 0x3F);   /*
  0013 9ee604   [4]             LDA   4,SP
  0016 a43f     [2]             AND   #63
  0018 cd0000   [6]             JSR   SPISendChar
  273:                                   * Mask address, 6bit addr. 
  274:                                   * Set write bit (i.e. 0). 
  275:                                   */
  276:    SPIWaitTransferDone();        /* 
  001b cd0000   [6]             JSR   SPIWaitTransferDone
  277:                                   * For this bit to be set, SPTED MUST be set.
  278:                                   * Now write content MSB
  279:                                   */
  280:    SPIClearRecieveDataReg(&u8TempValue);     /* 
  001e 95       [2]             TSX   
  001f cd0000   [6]             JSR   SPIClearRecieveDataReg
  281:                                   * Clear receive data register. SPI entirely 
  282:                                   * ready for read or write 
  283:                                   */
  284:    SPISendChar((UINT8)(u16Content >> 8));    /* Write MSB */       
  0022 9ee602   [4]             LDA   2,SP
  0025 cd0000   [6]             JSR   SPISendChar
  285:    SPIWaitTransferDone();        /* 
  0028 cd0000   [6]             JSR   SPIWaitTransferDone
  286:                                   * For this bit to be set, SPTED MUST be set. 
  287:                                   * Now write content LSB 
  288:                                   */
  289:    SPIClearRecieveDataReg(&u8TempValue);     /* 
  002b 95       [2]             TSX   
  002c cd0000   [6]             JSR   SPIClearRecieveDataReg
  290:                                   * Clear receive data register. SPI entirely 
  291:                                   * ready for read or write
  292:                                   */
  293:    SPISendChar((UINT8)(u16Content & 0x00FF));    /* Write LSB */
  002f 9ee603   [4]             LDA   3,SP
  0032 cd0000   [6]             JSR   SPISendChar
  294:    SPIWaitTransferDone();        /* 
  0035 cd0000   [6]             JSR   SPIWaitTransferDone
  295:                                   * For this bit to be set, SPTED MUST be set.
  296:                                   * Now read last of garbage
  297:                                   */
  298:    SPIClearRecieveDataReg(&u8TempValue);     /* 
  0038 95       [2]             TSX   
  0039 cd0000   [6]             JSR   SPIClearRecieveDataReg
  299:                                   * Clear receive data register. SPI entirely 
  300:                                   * ready for read or write 
  301:                                   */
  302:    DeAssertCE();                 /* Disables MC13192 SPI */
  003c cd0000   [6]             JSR   DeAssertCE
  303:    MC13192RestoreInterrupts();   /* Restore MC13192 interrupt status */
  003f cd0000   [6]             JSR   MC13192RestoreInterrupts
  304:  }
  0042 a704     [2]             AIS   #4
  0044 81       [6]             RTS   
  305:  
  306:  
  307:  /*!
  308:   * \brief SPIDrvRead : Read 1 word from SPI
  309:   *
  310:   * \param u8Addr - SPI address
  311:   *
  312:   * \return u16Data -  u16Data[0] is the MSB, u16Data[1] is the LSB
  313:   */
  314:  UINT16 SPIDrvRead(UINT8 u8Addr)
  315:  {
  0000 87       [2]             PSHA  
  0001 a7fd     [2]             AIS   #-3
  316:      UINT8 u8TempValue=0;
  0003 95       [2]             TSX   
  0004 6f02     [5]             CLR   2,X
  317:      UINT16  u16Data=0;            /* u16Data[0] is MSB, u16Data[1] is LSB */
  0006 6f01     [5]             CLR   1,X
  0008 7f       [4]             CLR   ,X
  318:  
  319:      SPIClearRecieveStatReg(&u8TempValue);  /* Clear status register (possible SPRF, SPTEF) */  
  0009 af02     [2]             AIX   #2
  000b cd0000   [6]             JSR   SPIClearRecieveStatReg
  320:      SPIClearRecieveDataReg(&u8TempValue);  /* 
  000e 95       [2]             TSX   
  000f af02     [2]             AIX   #2
  0011 cd0000   [6]             JSR   SPIClearRecieveDataReg
  321:                                   * Clear receive data register. SPI entirely 
  322:                                   * ready for read or write
  323:                                   */                       
  324:      MC13192DisableInterrupts(); /* Necessary to prevent double SPI access */
  0014 cd0000   [6]             JSR   MC13192DisableInterrupts
  325:      AssertCE();                 /* Enables MC13192 SPI */
  0017 cd0000   [6]             JSR   AssertCE
  326:      SPISendChar((u8Addr & 0x3f) | 0x80);   /* Mask address, 6bit addr, Set 
  001a 9ee604   [4]             LDA   4,SP
  001d a43f     [2]             AND   #63
  001f aa80     [2]             ORA   #-128
  0021 cd0000   [6]             JSR   SPISendChar
  327:                                               * read bit. 
  328:                                               */
  329:      SPIWaitTransferDone();      /* For this bit to be set, SPTED MUST be set */
  0024 cd0000   [6]             JSR   SPIWaitTransferDone
  330:      SPIClearRecieveDataReg(&u8TempValue);   /* 
  0027 95       [2]             TSX   
  0028 af02     [2]             AIX   #2
  002a cd0000   [6]             JSR   SPIClearRecieveDataReg
  331:                                   * Clear receive data register. SPI 
  332:                                   * entirely ready for read or write 
  333:                                   */
  334:      SPISendChar(u8Addr );       /*
  002d 9ee604   [4]             LDA   4,SP
  0030 cd0000   [6]             JSR   SPISendChar
  335:                                   * Dummy write. Receive register of SPI 
  336:                                   * will contain MSB
  337:                                   */
  338:      SPIWaitTransferDone();      /* 
  0033 cd0000   [6]             JSR   SPIWaitTransferDone
  339:                                   * For this bit to be set, SPTED MUST be 
  340:                                   * set. Get MSB
  341:                                   */
  342:      SPIReadMSB(&u16Data);               /* MSB */
  0036 95       [2]             TSX   
  0037 cd0000   [6]             JSR   SPIReadMSB
  343:      SPISendChar(u8Addr);             /*
  003a 9ee604   [4]             LDA   4,SP
  003d cd0000   [6]             JSR   SPISendChar
  344:                                         * Dummy write. Waiting until after 
  345:                                         * reading received data insures no 
  346:                                         * overrun 
  347:                                         */
  348:      SPIWaitTransferDone();            /* 
  0040 cd0000   [6]             JSR   SPIWaitTransferDone
  349:                                         * For this bit to be set, SPTED MUST be 
  350:                                         * set. Get LSB
  351:                                         */
  352:      ((UINT8*)&u16Data)[1] = SPIRead();    /* LSB */
  0043 cd0000   [6]             JSR   SPIRead
  0046 9ee702   [4]             STA   2,SP
  353:      DeAssertCE();                     /* Disables MC13192 SPI */
  0049 cd0000   [6]             JSR   DeAssertCE
  354:      MC13192RestoreInterrupts();       /* Restore MC13192 interrupt status */
  004c cd0000   [6]             JSR   MC13192RestoreInterrupts
  355:      return u16Data;
  004f 9efe01   [5]             LDHX  1,SP
  356:  }
  0052 a704     [2]             AIS   #4
  0054 81       [6]             RTS   
  357:  
  358:  /*!
  359:   * \brief SPIDrvRead2 : Read the second word from SPI
  360:   *
  361:   * \param u8Addr - SPI address
  362:   *
  363:   * \return u16Data -  u16Data[0] is the MSB, u16Data[1] is the LSB
  364:   */
  365:  UINT16 SPIDrvRead2(UINT8 u8Addr)
  366:  {
  0000 87       [2]             PSHA  
  0001 a7fd     [2]             AIS   #-3
  367:      UINT8 u8TempValue=0;
  0003 95       [2]             TSX   
  0004 6f02     [5]             CLR   2,X
  368:      UINT16  u16Data=0;            /* u16Data[0] is MSB, u16Data[1] is LSB */
  0006 6f01     [5]             CLR   1,X
  0008 7f       [4]             CLR   ,X
  369:  
  370:      SPIClearRecieveStatReg(&u8TempValue);  /* Clear status register (possible SPRF, SPTEF) */  
  0009 af02     [2]             AIX   #2
  000b cd0000   [6]             JSR   SPIClearRecieveStatReg
  371:      SPIClearRecieveDataReg(&u8TempValue);  /* 
  000e 95       [2]             TSX   
  000f af02     [2]             AIX   #2
  0011 cd0000   [6]             JSR   SPIClearRecieveDataReg
  372:                                   * Clear receive data register. SPI entirely 
  373:                                   * ready for read or write
  374:                                   */                       
  375:      MC13192DisableInterrupts(); /* Necessary to prevent double SPI access */
  0014 cd0000   [6]             JSR   MC13192DisableInterrupts
  376:      AssertCE();                 /* Enables MC13192 SPI */
  0017 cd0000   [6]             JSR   AssertCE
  377:      SPISendChar((u8Addr & 0x3f) | 0x80);   /* Mask address, 6bit addr, Set 
  001a 9ee604   [4]             LDA   4,SP
  001d a43f     [2]             AND   #63
  001f aa80     [2]             ORA   #-128
  0021 cd0000   [6]             JSR   SPISendChar
  378:                                               * read bit. 
  379:                                               */
  380:      SPIWaitTransferDone();      /* For this bit to be set, SPTED MUST be set */
  0024 cd0000   [6]             JSR   SPIWaitTransferDone
  381:      SPIClearRecieveDataReg(&u8TempValue);   /* 
  0027 95       [2]             TSX   
  0028 af02     [2]             AIX   #2
  002a cd0000   [6]             JSR   SPIClearRecieveDataReg
  382:                                   * Clear receive data register. SPI 
  383:                                   * entirely ready for read or write 
  384:                                   */
  385:      SPISendChar(u8Addr );       /*
  002d 9ee604   [4]             LDA   4,SP
  0030 cd0000   [6]             JSR   SPISendChar
  386:                                   * Dummy write. Receive register of SPI 
  387:                                   * will contain MSB
  388:                                   */
  389:      SPIWaitTransferDone();      /* 
  0033 cd0000   [6]             JSR   SPIWaitTransferDone
  390:                                   * For this bit to be set, SPTED MUST be 
  391:                                   * set. Get MSB
  392:                                   */
  393:      SPIReadMSB(&u16Data);               /* MSB */
  0036 95       [2]             TSX   
  0037 cd0000   [6]             JSR   SPIReadMSB
  394:      SPISendChar(u8Addr);             /*
  003a 9ee604   [4]             LDA   4,SP
  003d cd0000   [6]             JSR   SPISendChar
  395:                                         * Dummy write. Waiting until after 
  396:                                         * reading received data insures no 
  397:                                         * overrun 
  398:                                         */
  399:      SPIWaitTransferDone();            /* 
  0040 cd0000   [6]             JSR   SPIWaitTransferDone
  400:                                         * For this bit to be set, SPTED MUST be 
  401:                                         * set. Get LSB
  402:                                         */
  403:      SPIReadLSB(&u16Data);               /* LSB */
  0043 95       [2]             TSX   
  0044 cd0000   [6]             JSR   SPIReadLSB
  404:      SPISendChar(u8Addr);             /*
  0047 9ee604   [4]             LDA   4,SP
  004a cd0000   [6]             JSR   SPISendChar
  405:                                         * Dummy write. Waiting until after 
  406:                                         * reading received data insures no 
  407:                                         * overrun 
  408:                                         */
  409:      SPIWaitTransferDone();            /* 
  004d cd0000   [6]             JSR   SPIWaitTransferDone
  410:                                         * For this bit to be set, SPTED MUST be 
  411:                                         * set. Get LSB
  412:                                         */
  413:      SPIReadMSB(&u16Data);               /* MSB */
  0050 95       [2]             TSX   
  0051 cd0000   [6]             JSR   SPIReadMSB
  414:      SPISendChar(u8Addr);             /*
  0054 9ee604   [4]             LDA   4,SP
  0057 cd0000   [6]             JSR   SPISendChar
  415:                                         * Dummy write. Waiting until after 
  416:                                         * reading received data insures no 
  417:                                         * overrun 
  418:                                         */
  419:      SPIWaitTransferDone();            /* 
  005a cd0000   [6]             JSR   SPIWaitTransferDone
  420:                                         * For this bit to be set, SPTED MUST be 
  421:                                         * set. Get LSB
  422:                                         */
  423:      SPIReadLSB(&u16Data);               /* LSB */
  005d 95       [2]             TSX   
  005e cd0000   [6]             JSR   SPIReadLSB
  424:      DeAssertCE();                     /* Disables MC13192 SPI */
  0061 cd0000   [6]             JSR   DeAssertCE
  425:      MC13192RestoreInterrupts();       /* Restore MC13192 interrupt status */
  0064 cd0000   [6]             JSR   MC13192RestoreInterrupts
  426:      return u16Data;
  0067 9efe01   [5]             LDHX  1,SP
  427:  }
  006a a704     [2]             AIS   #4
  006c 81       [6]             RTS   
  428:  
  429:  
  430:  /*!
  431:   * \brief RAMDrvWriteTx : Write a block of data to TX packet RAM, whichever is selected
  432:   *
  433:   * \param *psTxPkt - Packet to write
  434:   *
  435:   */
  436:  void RAMDrvWriteTx(tTxPacket *psTxPkt)
  437:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fb     [2]             AIS   #-5
  438:      UINT8 i, u8TempByte=0, u8TempValue=0;   /* Temporary counters */ 
  0004 95       [2]             TSX   
  0005 7f       [4]             CLR   ,X
  439:      UINT8 u8MinLen=0;
  440:  
  441:      UINT16  u16Reg=0;                     /* TX packet length register value */
  442:  
  443:      if (gsPhyOptions.Bits.u1PromiscuousMode)
  0006 c60001   [4]             LDA   gsPhyOptions:1
  0009 a501     [2]             BIT   #1
  000b 2704     [3]             BEQ   L11 ;abs = 0011
  444:        u8MinLen = 3;
  000d a603     [2]             LDA   #3
  000f 2002     [3]             BRA   L13 ;abs = 0013
  0011          L11:    
  445:      else
  446:        u8MinLen = 5;
  0011 a605     [2]             LDA   #5
  0013          L13:    
  0013 e704     [3]             STA   4,X
  447:  
  448:      u16Reg = SPIDrvRead(TX_PKT_LEN);    /* 
  0015 a603     [2]             LDA   #3
  0017 cd0000   [6]             JSR   SPIDrvRead
  001a 9eff03   [5]             STHX  3,SP
  449:                                           * Read the TX packet length register 
  450:                                           * contents 
  451:                                           */
  452:      u16Reg = (0xFF80 & u16Reg) | (psTxPkt->u8DataLength + (u8MinLen - 1)); /* 
  001d 9efe06   [5]             LDHX  6,SP
  0020 f6       [3]             LDA   ,X
  0021 87       [2]             PSHA  
  0022 9ee606   [4]             LDA   6,SP
  0025 87       [2]             PSHA  
  0026 8c       [1]             CLRH  
  0027 88       [3]             PULX  
  0028 afff     [2]             AIX   #-1
  002a 9f       [1]             TXA   
  002b 8b       [2]             PSHH  
  002c 95       [2]             TSX   
  002d eb01     [3]             ADD   1,X
  002f e701     [3]             STA   1,X
  0031 86       [3]             PULA  
  0032 a900     [2]             ADC   #0
  0034 87       [2]             PSHA  
  0035 e605     [3]             LDA   5,X
  0037 a480     [2]             AND   #-128
  0039 ea01     [3]             ORA   1,X
  003b e701     [3]             STA   1,X
  003d e604     [3]             LDA   4,X
  003f fa       [3]             ORA   ,X
  0040 87       [2]             PSHA  
  0041 ee01     [3]             LDX   1,X
  0043 8a       [3]             PULH  
  0044 9eff05   [5]             STHX  5,SP
  453:                                                              * Mask out old 
  454:                                                              * length setting and
  455:                                                              * update. Add 2 for
  456:                                                              * CRC and 2 for code bytes
  457:                                                              */
  458:      SPIDrvWrite(TX_PKT_LEN, u16Reg);    /* Update the TX packet length field */
  0047 a603     [2]             LDA   #3
  0049 cd0000   [6]             JSR   SPIDrvWrite
  459:      SPIClearRecieveStatReg(&u8TempValue);/* Clear status register 
  004c 95       [2]             TSX   
  004d af02     [2]             AIX   #2
  004f cd0000   [6]             JSR   SPIClearRecieveStatReg
  460:                                           * (possible SPRF, SPTEF) 
  461:                                           */
  462:      SPIClearRecieveDataReg(&u8TempValue);   /* 
  0052 95       [2]             TSX   
  0053 af02     [2]             AIX   #2
  0055 cd0000   [6]             JSR   SPIClearRecieveDataReg
  463:                                   * Clear receive data register. SPI entirely
  464:                                   * ready for read or write
  465:                                   */                       
  466:      MC13192DisableInterrupts(); /* Necessary to prevent double SPI access */
  0058 cd0000   [6]             JSR   MC13192DisableInterrupts
  467:      AssertCE();                 /* Enables MC13192 SPI */
  005b cd0000   [6]             JSR   AssertCE
  468:      SPISendChar(TX_PKT);        /* SPI TX ram data register */
  005e a602     [2]             LDA   #2
  0060 cd0000   [6]             JSR   SPISendChar
  469:      SPIWaitTransferDone();      /* 
  0063 cd0000   [6]             JSR   SPIWaitTransferDone
  470:                                   * For this bit to be set, SPTED MUST be set. 
  471:                                   * Now write content MSB 
  472:                                   */
  473:      SPIClearRecieveDataReg(&u8TempValue);   /* 
  0066 95       [2]             TSX   
  0067 af02     [2]             AIX   #2
  0069 cd0000   [6]             JSR   SPIClearRecieveDataReg
  474:                                   * Clear receive data register. SPI entirely 
  475:                                   * ready for read or write
  476:                                   */
  477:      if (!gsPhyOptions.Bits.u1PromiscuousMode)
  006c c60001   [4]             LDA   gsPhyOptions:1
  006f a501     [2]             BIT   #1
  0071 a702     [2]             AIS   #2
  0073 2614     [3]             BNE   L89 ;abs = 0089
  478:      {
  479:        
  480:        SPISendChar(0xFF);          /* Send 1st Code Byte */
  0075 a6ff     [2]             LDA   #-1
  0077 cd0000   [6]             JSR   SPISendChar
  481:        SPIWaitTransferDone();      /* 
  007a cd0000   [6]             JSR   SPIWaitTransferDone
  482:                                     * For this bit to be set, SPTED MUST be set. 
  483:                                     * Now write content MSB 
  484:                                     */
  485:        SPISendChar(0x7E);          /* Send 2nd Code Byte */
  007d a67e     [2]             LDA   #126
  007f cd0000   [6]             JSR   SPISendChar
  486:        SPIWaitTransferDone();      /* 
  0082 cd0000   [6]             JSR   SPIWaitTransferDone
  487:                                     * For this bit to be set, SPTED MUST be set. 
  488:                                     * Now write content MSB 
  489:                                     */
  490:        SPIClearRecieveDataReg(&u8TempValue);   /* 
  0085 95       [2]             TSX   
  0086 cd0000   [6]             JSR   SPIClearRecieveDataReg
  0089          L89:    
  491:                                     * Clear receive data register. SPI entirely 
  492:                                     * ready for read or write
  493:                                     */
  494:      }
  495:      u8TempByte = 0;             /* Byte counter for *contents */
  496:      /* Word loop. Round up. */ 
  497:      for (i=0; i<((psTxPkt->u8DataLength+1) >> 1); i++) { 
  0089 9e6f02   [6]             CLR   2,SP
  008c 4f       [1]             CLRA  
  008d 204b     [3]             BRA   LDA ;abs = 00da
  008f          L8F:    
  498:          SPISendChar(psTxPkt->pu8Data[u8TempByte + 1]);  /* Write MSB */
  008f 87       [2]             PSHA  
  0090 8c       [1]             CLRH  
  0091 9eee01   [4]             LDX   1,SP
  0094 af01     [2]             AIX   #1
  0096 89       [2]             PSHX  
  0097 8b       [2]             PSHH  
  0098 9efe09   [5]             LDHX  9,SP
  009b 9ee602   [4]             LDA   2,SP
  009e eb02     [3]             ADD   2,X
  00a0 9ee702   [4]             STA   2,SP
  00a3 86       [3]             PULA  
  00a4 e901     [3]             ADC   1,X
  00a6 87       [2]             PSHA  
  00a7 8a       [3]             PULH  
  00a8 88       [3]             PULX  
  00a9 f6       [3]             LDA   ,X
  00aa cd0000   [6]             JSR   SPISendChar
  499:          SPIWaitTransferDone();  /* 
  00ad cd0000   [6]             JSR   SPIWaitTransferDone
  500:                                   * For this bit to be set, SPTED MUST be set. 
  501:                                   * Now write content LSB 
  502:                                   */
  503:          SPIClearRecieveDataReg(&u8TempValue);/* 
  00b0 95       [2]             TSX   
  00b1 af01     [2]             AIX   #1
  00b3 cd0000   [6]             JSR   SPIClearRecieveDataReg
  504:                                   * Clear receive data register. SPI entirely
  505:                                   * ready for read or write
  506:                                   */
  507:          SPISendChar(psTxPkt->pu8Data[u8TempByte]);     /* Write LSB */          
  00b6 9efe07   [5]             LDHX  7,SP
  00b9 9ee601   [4]             LDA   1,SP
  00bc eb02     [3]             ADD   2,X
  00be 87       [2]             PSHA  
  00bf 4f       [1]             CLRA  
  00c0 e901     [3]             ADC   1,X
  00c2 87       [2]             PSHA  
  00c3 8a       [3]             PULH  
  00c4 88       [3]             PULX  
  00c5 f6       [3]             LDA   ,X
  00c6 cd0000   [6]             JSR   SPISendChar
  508:          u8TempByte = (UINT8)(u8TempByte + 2);           /* Increment byte counter */
  00c9 86       [3]             PULA  
  00ca ab02     [2]             ADD   #2
  509:          SPIWaitTransferDone();  /* For this bit to be set, SPTED MUST be set.*/
  00cc 87       [2]             PSHA  
  00cd cd0000   [6]             JSR   SPIWaitTransferDone
  510:          SPIClearRecieveDataReg(&u8TempValue);/* 
  00d0 95       [2]             TSX   
  00d1 af01     [2]             AIX   #1
  00d3 cd0000   [6]             JSR   SPIClearRecieveDataReg
  00d6 9e6c03   [6]             INC   3,SP
  00d9 86       [3]             PULA  
  00da          LDA:    
  00da 9efe06   [5]             LDHX  6,SP
  00dd 87       [2]             PSHA  
  00de f6       [3]             LDA   ,X
  00df 87       [2]             PSHA  
  00e0 8c       [1]             CLRH  
  00e1 88       [3]             PULX  
  00e2 af01     [2]             AIX   #1
  00e4 8b       [2]             PSHH  
  00e5 86       [3]             PULA  
  00e6 47       [1]             ASRA  
  00e7 56       [1]             RORX  
  00e8 89       [2]             PSHX  
  00e9 87       [2]             PSHA  
  00ea 95       [2]             TSX   
  00eb e604     [3]             LDA   4,X
  00ed e001     [3]             SUB   1,X
  00ef 4f       [1]             CLRA  
  00f0 f2       [3]             SBC   ,X
  00f1 a702     [2]             AIS   #2
  00f3 cd0000   [6]             JSR   _PUSH_CC
  00f6 e602     [3]             LDA   2,X
  00f8 cd0000   [6]             JSR   _POP_CC
  00fb 8a       [3]             PULH  
  00fc 9191     [3]             BLT   L8F ;abs = 008f
  511:                                   * Clear receive data register. SPI entirely 
  512:                                   * ready for read or write
  513:                                   */
  514:      }
  515:      DeAssertCE();                   /* Disables MC13192 SPI */
  00fe cd0000   [6]             JSR   DeAssertCE
  516:      MC13192RestoreInterrupts();     /* Restore MC13192 interrupt status */
  0101 cd0000   [6]             JSR   MC13192RestoreInterrupts
  517:  }
  0104 a707     [2]             AIS   #7
  0106 81       [6]             RTS   
  518:  
  519:  
  520:  /*!
  521:   * \brief RAMDrvReadRx : Read a block of data from RX packet RAM, whichever is selected
  522:   *
  523:   * \param *psRxPkt - Packet received
  524:   *
  525:   * \return u8Status
  526:   */
  527:  UINT8 RAMDrvReadRx(tRxPacket *psRxPkt)
  528:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7f9     [2]             AIS   #-7
  529:      UINT8 i, u8TempByte=0;        /* Temporary counters. */
  530:      UINT8 u8MinLen=0;
  531:      UINT8 u8TempValue=0;          /* 
  0004 95       [2]             TSX   
  0005 7f       [4]             CLR   ,X
  532:                                   * Used by SPIClearRecieveDataReg to 
  533:                                   * flush SPI1D register during read
  534:                                   */
  535:      UINT8  u8Status = 0;        /* Holder for the return value */
  0006 6f06     [5]             CLR   6,X
  536:      UINT16 u16RxLength;
  537:      
  538:      if (gsPhyOptions.Bits.u1PromiscuousMode)
  0008 c60001   [4]             LDA   gsPhyOptions:1
  000b a501     [2]             BIT   #1
  000d 2704     [3]             BEQ   L13 ;abs = 0013
  539:        u8MinLen = 3;
  000f a603     [2]             LDA   #3
  0011 2002     [3]             BRA   L15 ;abs = 0015
  0013          L13:    
  540:      else
  541:        u8MinLen = 5;
  0013 a605     [2]             LDA   #5
  0015          L15:    
  0015 e705     [3]             STA   5,X
  542:    
  543:      u16RxLength = SPIDrvRead(RX_PKT_LEN);   /* 
  0017 a62d     [2]             LDA   #45
  0019 cd0000   [6]             JSR   SPIDrvRead
  001c 9eff02   [5]             STHX  2,SP
  544:                                               * Read the RX packet length 
  545:                                               * register contents 
  546:                                               */
  547:      u16RxLength &= 0x007F;          /* Mask out all but the RX packet length */
  001f 95       [2]             TSX   
  0020 e602     [3]             LDA   2,X
  0022 a47f     [2]             AND   #127
  0024 e702     [3]             STA   2,X
  0026 6f01     [5]             CLR   1,X
  548:  
  549:      /* MC13192 reports length with 2 CRC bytes and 2 Code bytes,
  550:       * remove them. 
  551:       */
  552:      if (u16RxLength >= u8MinLen) {
  0028 ee05     [3]             LDX   5,X
  002a 8c       [1]             CLRH  
  002b 9ef302   [6]             CPHX  2,SP
  002e 220c     [3]             BHI   L3C ;abs = 003c
  553:          psRxPkt->u8DataLength = u16RxLength - (u8MinLen - 1); /*
  0030 5a       [1]             DECX  
  0031 89       [2]             PSHX  
  0032 95       [2]             TSX   
  0033 f0       [3]             SUB   ,X
  0034 9efe09   [5]             LDHX  9,SP
  0037 e701     [3]             STA   1,X
  554:                                                    * Less byte code
  555:                                                    * and CRC
  556:                                                    */
  557:      }
  0039 8a       [3]             PULH  
  003a 2005     [3]             BRA   L41 ;abs = 0041
  003c          L3C:    
  558:      else {
  559:          psRxPkt->u8DataLength = 0;
  003c 9efe08   [5]             LDHX  8,SP
  003f 6f01     [5]             CLR   1,X
  0041          L41:    
  560:      }
  561:          
  562:      if ((psRxPkt->u8DataLength >= 1) && \
  0041 9efe08   [5]             LDHX  8,SP
  0044 6d01     [4]             TST   1,X
  0046 2603     [3]             BNE   L4B ;abs = 004b
  0048 cc012f   [4]             JMP   L12F ;abs = 012f
  004b          L4B:    
  004b f6       [3]             LDA   ,X
  004c e101     [3]             CMP   1,X
  004e 2403     [3]             BCC   L53 ;abs = 0053
  0050 cc012f   [4]             JMP   L12F ;abs = 012f
  0053          L53:    
  563:          (psRxPkt->u8DataLength <= psRxPkt->u8MaxDataLength)) { /* 
  564:                                                            * If <5, the packet 
  565:                                                            * is garbage
  566:                                                            */
  567:          SPIClearRecieveStatReg(&u8TempValue);   /* Clear status register (SPRF, SPTEF) */  
  0053 95       [2]             TSX   
  0054 cd0000   [6]             JSR   SPIClearRecieveStatReg
  568:          SPIClearRecieveDataReg(&u8TempValue);   /* 
  0057 95       [2]             TSX   
  0058 cd0000   [6]             JSR   SPIClearRecieveDataReg
  569:                                       * Clear receive data register. 
  570:                                       * SPI entirely ready for read or write
  571:                                       */                       
  572:          MC13192DisableInterrupts(); /* Necessary to prevent double SPI access */
  005b cd0000   [6]             JSR   MC13192DisableInterrupts
  573:          AssertCE();                 /* Enables MC13192 SPI */
  005e cd0000   [6]             JSR   AssertCE
  574:          SPISendChar(RX_PKT | 0x80); /* SPI RX ram data register */
  0061 a681     [2]             LDA   #-127
  0063 cd0000   [6]             JSR   SPISendChar
  575:          SPIWaitTransferDone();      /* For this bit to be set, SPTED 
  0066 cd0000   [6]             JSR   SPIWaitTransferDone
  576:                                       * MUST be set.
  577:                                       */
  578:          SPIClearRecieveDataReg(&u8TempValue);   /* 
  0069 95       [2]             TSX   
  006a cd0000   [6]             JSR   SPIClearRecieveDataReg
  579:                                       * Clear receive data register. 
  580:                                       * SPI entirely ready for read or write 
  581:                                       */
  582:          SPISendChar(u8TempValue);   /* 
  006d 95       [2]             TSX   
  006e f6       [3]             LDA   ,X
  006f cd0000   [6]             JSR   SPISendChar
  583:                                       * Dummy write. Receive register of SPI will 
  584:                                       * contain MSB garbage for first read 
  585:                                       */
  586:          SPIWaitTransferDone();      /* For this bit to be set, SPTED MUST be set.*/
  0072 cd0000   [6]             JSR   SPIWaitTransferDone
  587:          SPIClearRecieveDataReg(&u8TempValue);   /* 
  0075 95       [2]             TSX   
  0076 cd0000   [6]             JSR   SPIClearRecieveDataReg
  588:                                       * Clear receive data register. 
  589:                                       * SPI entirely ready for read or write 
  590:                                       */
  591:          SPISendChar(u8TempValue);   /* 
  0079 95       [2]             TSX   
  007a f6       [3]             LDA   ,X
  007b cd0000   [6]             JSR   SPISendChar
  592:                                       * Dummy write. Receive register of SPI will 
  593:                                       * contain LSB garbage for first read 
  594:                                       */
  595:          SPIWaitTransferDone();      /* For this bit to be set, SPTED MUST be set.*/
  007e cd0000   [6]             JSR   SPIWaitTransferDone
  596:          SPIClearRecieveDataReg(&u8TempValue);   /* 
  0081 95       [2]             TSX   
  0082 cd0000   [6]             JSR   SPIClearRecieveDataReg
  597:                                       * Clear receive data register. 
  598:                                       * SPI entirely ready for read or write 
  599:                                       */
  600:          if (gsPhyOptions.Bits.u1PromiscuousMode == 0) 
  0085 c60001   [4]             LDA   gsPhyOptions:1
  0088 a501     [2]             BIT   #1
  008a 2618     [3]             BNE   LA4 ;abs = 00a4
  601:          {
  602:            
  603:                                        /* Byte codes */
  604:            SPISendChar(u8TempValue);   /* 
  008c 95       [2]             TSX   
  008d f6       [3]             LDA   ,X
  008e cd0000   [6]             JSR   SPISendChar
  605:                                         * Dummy write. Receive register of SPI will 
  606:                                         * contain LSB garbage for first read 
  607:                                         */
  608:            SPIWaitTransferDone();      /* For this bit to be set, SPTED MUST be set.*/
  0091 cd0000   [6]             JSR   SPIWaitTransferDone
  609:            u8TempValue = SPIRead();    /* Read first code byte */
  0094 cd0000   [6]             JSR   SPIRead
  0097 95       [2]             TSX   
  0098 f7       [2]             STA   ,X
  610:            SPISendChar(u8TempValue);   /* 
  0099 cd0000   [6]             JSR   SPISendChar
  611:                                         * Dummy write. Receive register of SPI will 
  612:                                         * contain LSB garbage for first read 
  613:                                         */
  614:            SPIWaitTransferDone();      /* For this bit to be set, SPTED MUST be set.*/
  009c cd0000   [6]             JSR   SPIWaitTransferDone
  615:            u8TempValue = SPIRead();    /* Read second code byte */
  009f cd0000   [6]             JSR   SPIRead
  00a2 95       [2]             TSX   
  00a3 f7       [2]             STA   ,X
  00a4          LA4:    
  616:  
  617:          }
  618:          u8TempByte = 0;             /* Byte counter for *contents */
  00a4 95       [2]             TSX   
  00a5 6f03     [5]             CLR   3,X
  619:          /* Word loop. Round up. Deduct CRC. */
  620:          for (i=0; i<((u16RxLength-1)>>1); i++) { 
  00a7 6f04     [5]             CLR   4,X
  00a9 205d     [3]             BRA   L108 ;abs = 0108
  00ab          LAB:    
  621:              SPISendChar(u8TempValue);/* 
  00ab 95       [2]             TSX   
  00ac f6       [3]             LDA   ,X
  00ad cd0000   [6]             JSR   SPISendChar
  622:                                       * Dummy write. Receive register of SPI 
  623:                                       * will contain MSB
  624:                                       */
  625:              SPIWaitTransferDone();  /* 
  00b0 cd0000   [6]             JSR   SPIWaitTransferDone
  626:                                       * For this bit to be set, SPTED MUST be 
  627:                                       * set. Get MSB
  628:                                       */
  629:              /* For a trailing garbage byte, just read and discard */
  630:              if ((u8TempByte + 3) == u16RxLength) { 
  00b3 9ee604   [4]             LDA   4,SP
  00b6 8c       [1]             CLRH  
  00b7 97       [1]             TAX   
  00b8 af03     [2]             AIX   #3
  00ba 9ef302   [6]             CPHX  2,SP
  00bd 2606     [3]             BNE   LC5 ;abs = 00c5
  631:                  SPIClearRecieveDataReg(&u8TempValue);                  /* Discard */
  00bf 95       [2]             TSX   
  00c0 cd0000   [6]             JSR   SPIClearRecieveDataReg
  632:              }
  00c3 201f     [3]             BRA   LE4 ;abs = 00e4
  00c5          LC5:    
  633:              else {
  634:                  psRxPkt->pu8Data[u8TempByte + 1] = SPIRead();   /* Read MSB */
  00c5 8c       [1]             CLRH  
  00c6 97       [1]             TAX   
  00c7 af01     [2]             AIX   #1
  00c9 9f       [1]             TXA   
  00ca 8b       [2]             PSHH  
  00cb 9efe09   [5]             LDHX  9,SP
  00ce eb03     [3]             ADD   3,X
  00d0 87       [2]             PSHA  
  00d1 9ee602   [4]             LDA   2,SP
  00d4 e902     [3]             ADC   2,X
  00d6 9ee702   [4]             STA   2,SP
  00d9 cd0000   [6]             JSR   SPIRead
  00dc 9eee02   [4]             LDX   2,SP
  00df 89       [2]             PSHX  
  00e0 8a       [3]             PULH  
  00e1 88       [3]             PULX  
  00e2 f7       [2]             STA   ,X
  00e3 8a       [3]             PULH  
  00e4          LE4:    
  635:              }
  636:              SPISendChar(u8TempValue);/*
  00e4 95       [2]             TSX   
  00e5 f6       [3]             LDA   ,X
  00e6 cd0000   [6]             JSR   SPISendChar
  637:                                       * Dummy write. Receive register of SPI 
  638:                                       * will contain LSB
  639:                                       */
  640:              SPIWaitTransferDone();  /* 
  00e9 cd0000   [6]             JSR   SPIWaitTransferDone
  641:                                       * For this bit to be set, SPTED MUST be
  642:                                       * set. Get LSB
  643:                                       */
  644:              psRxPkt->pu8Data[u8TempByte] = SPIRead();   /* Read LSB */
  00ec 9efe08   [5]             LDHX  8,SP
  00ef 9ee604   [4]             LDA   4,SP
  00f2 eb03     [3]             ADD   3,X
  00f4 87       [2]             PSHA  
  00f5 4f       [1]             CLRA  
  00f6 e902     [3]             ADC   2,X
  00f8 87       [2]             PSHA  
  00f9 cd0000   [6]             JSR   SPIRead
  00fc 8a       [3]             PULH  
  00fd 88       [3]             PULX  
  00fe f7       [2]             STA   ,X
  645:              u8TempByte = (UINT8)(u8TempByte + 2);       /* Increment byte counter */
  00ff 95       [2]             TSX   
  0100 e603     [3]             LDA   3,X
  0102 ab02     [2]             ADD   #2
  0104 e703     [3]             STA   3,X
  0106 6c04     [5]             INC   4,X
  0108          L108:   
  0108 9efe02   [5]             LDHX  2,SP
  010b afff     [2]             AIX   #-1
  010d 8b       [2]             PSHH  
  010e 86       [3]             PULA  
  010f 44       [1]             LSRA  
  0110 56       [1]             RORX  
  0111 87       [2]             PSHA  
  0112 89       [2]             PSHX  
  0113 86       [3]             PULA  
  0114 88       [3]             PULX  
  0115 87       [2]             PSHA  
  0116 89       [2]             PSHX  
  0117 95       [2]             TSX   
  0118 e606     [3]             LDA   6,X
  011a e001     [3]             SUB   1,X
  011c 4f       [1]             CLRA  
  011d f2       [3]             SBC   ,X
  011e a702     [2]             AIS   #2
  0120 2589     [3]             BCS   LAB ;abs = 00ab
  646:          }
  647:          DeAssertCE();               /* Disables MC13192 SPI */
  0122 cd0000   [6]             JSR   DeAssertCE
  648:          psRxPkt->u8Status = SUCCESS;
  0125 9efe08   [5]             LDHX  8,SP
  0128 a677     [2]             LDA   #119
  012a e704     [3]             STA   4,X
  649:          MC13192RestoreInterrupts(); /* Restore MC13192 interrupt status */
  012c cd0000   [6]             JSR   MC13192RestoreInterrupts
  012f          L12F:   
  650:      }
  651:      /* Check to see if a larger packet than desired is received. */  
  652:      if (psRxPkt->u8DataLength > psRxPkt->u8MaxDataLength) {
  012f 9efe08   [5]             LDHX  8,SP
  0132 f6       [3]             LDA   ,X
  0133 e101     [3]             CMP   1,X
  0135 2404     [3]             BCC   L13B ;abs = 013b
  653:          psRxPkt->u8Status = OVERFLOW;
  0137 a601     [2]             LDA   #1
  0139 e704     [3]             STA   4,X
  013b          L13B:   
  654:      }
  655:      return u8Status;  
  013b 9ee607   [4]             LDA   7,SP
  656:  }
  013e a709     [2]             AIS   #9
  0140 81       [6]             RTS   
  657:  
  658:  
